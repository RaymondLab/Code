'--------------------------------------------------------------------------------
' IMPORT RIG-SPECIFIC PARAMETERS AND UNIVERSAL PARAMETERS
'--------------------------------------------------------------------------------
#include "C:\\Users\\Public\\RaymondLabCode\\Experiment Protocols\\RigChoice.s2s"
#include "C:\\Users\\Public\\RaymondLabCode\\Experiment Protocols\\Parameters_Universal.s2s"

'--------------------------------------------------------------------------------
' MAIN PROGRAM
'--------------------------------------------------------------------------------
var originalsinAmpChair := sinAmpChair;
ToolbarConfig();
var blockNum := 1;
var expmtIndx := 0;
var segLength := 45;
nBlocks% := 10;
var stimChoice := 0;

' 0 = GAP A
' 1 = Gap B
' 2 = Segment
' 9 = quit experiment
const Order%[] := {0, 1, 2,
                   0, 9};
'--------------------------------------------------------------------------------
' Toolbar Callbacks
'--------------------------------------------------------------------------------
Func ToolbarIdle%()
  'This function calls repeatedly whenever nothing else is happening
  'if runExmpt=1, it is used to run a full expmt automatically.  -HP
  'expmtMode: 0=habit, 1=0x, 2=2x, 3=ipsi stim, 4=contra stim
  'test: 0=wait, 1=test, 2=train

  ' Check a valid sampling view is running
  var currView := ViewKind();
  if  currView <> 0 then
      return 1;
  endif;

  ' Keep sine wave from drifting
  if MaxTime() > (prevTime + 1/sinHzChair) then
    if driftFix = 1 then
      driftFix%();
    endif;
  endif;

  'If an experiment is running:
  if runExpmt% = 1 then

      'Check the time. Seconds is the current time - compare it to the goal time of each segment
      if  MaxTime() > goalTime then

        docase

          ' GAP A
          case Order%[expmtIndx] = 0 then
            SampleKey("x");
            goalTime := MaxTime() + 7.5;
            ToolbarInit%(); Yield();

          ' GAP B
          case Order%[expmtIndx] = 1 then
            goalTime := MaxTime() + 7.5;
            ToolbarInit%(); Yield();
            runFlash(); Yield();
            ToolbarInit%(); Yield();

          ' Segment
          case Order%[expmtIndx] = 2 then
            SampleKey("X");
            goalTime := MaxTime() + segLength;

            if expmtMode <> 0 then
              ToolbarLightOn%(); Yield();
            endif

            blockNum := blockNum + 1;

            if blockNum <= nBlocks% then
              expmtIndx := -1;
            endif

            'ToolbarSineStart%();
            if stimChoice then
              ToolbarLasersOn%(); Yield();
              ToolbarSineStart%();
            else
              ToolbarStimOn%();
            endif


          case Order%[expmtIndx] = 9 then
            ToolbarQuitExpmt%();
            Return(1);

        endcase;
        expmtIndx := expmtIndx + 1;
      endif;
  endif;
  Return(1);
End

'--------------------------------------------------------------------------------
'Configure expmt settings window
'--------------------------------------------------------------------------------
Func ToolbarConfigExpmt%()
  DlgCreate("Hyun Geun Jan2020 Expmt2: Experiment settings");  'Start new dialog
  DlgList(1,"Expmt mode", "VORD|OKR|x0|x2");
  DlgInteger(2,"Number of Segments",0,100,0,0,1);
  DlgReal(3,"Segment length (s)",0,5000);
  DlgReal(4,"Ipsi/contra or Bilateral Stim (0 or 1)",0,1);

  DlgShow(expmtMode, nBlocks%, segLength, stimChoice);

  docase
  case expmtMode = 0 then     'VORD
      sinPhDrum := 90;
      sinPhChair := 90;
      sinAmpChair := 10;
      sinAmpDrum := 0;
  case expmtMode = 1 then     'OKR
      sinPhDrum := 90;
      sinPhChair := 90;
      sinAmpChair := 0;
      sinAmpDrum := 10;
  case expmtMode = 2 then     'x0
      sinPhDrum := 90;
      sinPhChair := 90;
      sinAmpChair := 10;
      sinAmpDrum := 10;
  case expmtMode = 3  then     'x2
      sinPhDrum := 90;
      sinPhChair := -90;
      sinAmpChair := 10;
      sinAmpDrum := 10;
  endcase;

  if stimChoice = 0 then
    ToolbarPulseConfig%()
  endif


  SetSequencerValues();
  Return(1);
End
